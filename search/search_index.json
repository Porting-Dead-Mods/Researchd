{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the Researchd Wiki","text":"<p>Researchd is a mod that aims to add a Factorio-like research system to Minecraft, while also trying to be as modular and as addon friendly as possible.</p> <p>Yes, we went full circle.</p>"},{"location":"#contribution","title":"Contribution","text":"<p>Any contribution would be gladly accepted through pull requests on our GitHub.</p>"},{"location":"addons/","title":"Addons","text":"<p>This page provides an in-depth guide on how to create addons for Researchd, including creating custom research effects and methods.</p>"},{"location":"addons/#researcheffect-interface","title":"<code>ResearchEffect</code> Interface","text":"<p>A <code>ResearchEffect</code> is triggered when a research is successfully completed. It's how you grant rewards to the player, such as unlocking recipes, giving items, or applying any other custom effect.</p> <p>To create a research effect, you need to implement the <code>ResearchEffect</code> interface.</p> <pre><code>public interface ResearchEffect {\n    void onUnlock(Level level, Player player, ResourceKey&lt;Research&gt; research);\n    ResourceLocation id();\n    ResearchEffectSerializer&lt;?&gt; getSerializer();\n    // ... other methods\n}\n</code></pre>"},{"location":"addons/#key-methods","title":"Key Methods","text":"<ul> <li> <p><code>void onUnlock(Level level, Player player, ResourceKey&lt;Research&gt; research)</code>: This is the core method of the interface. It's called on the server side when the specified <code>research</code> is completed. You can use the <code>player</code> and <code>level</code> objects to apply your effects.</p> </li> <li> <p><code>ResearchEffectSerializer&lt;?&gt; getSerializer()</code>: Every research effect needs a serializer to handle networking and saving to disk. You'll need to create a serializer for your custom effect and return it here.</p> </li> </ul>"},{"location":"addons/#serialization-and-registration","title":"Serialization and Registration","text":"<p>To allow your <code>ResearchEffect</code> to be saved and synced, you need to create a <code>ResearchEffectSerializer</code> and register it.</p> <ol> <li> <p>Create the Serializer: Create a class that implements <code>ResearchEffectSerializer&lt;YourResearchEffect&gt;</code>. You'll need to implement <code>codec()</code> and <code>streamCodec()</code>.</p> <pre><code>public static final class Serializer implements ResearchEffectSerializer&lt;YourResearchEffect&gt; {\n    public static final Serializer INSTANCE = new Serializer();\n    public static final MapCodec&lt;YourResearchEffect&gt; CODEC = RecordCodecBuilder.mapCodec(instance -&gt; instance.group(\n            // ... your fields here\n    ).apply(instance, YourResearchEffect::new));\n\n    public static final StreamCodec&lt;RegistryFriendlyByteBuf, YourResearchEffect&gt; STREAM_CODEC = StreamCodec.composite(\n            // ... your fields here\n    );\n\n    @Override\n    public @NotNull MapCodec&lt;YourResearchEffect&gt; codec() {\n        return CODEC;\n    }\n\n    @Override\n    public @NotNull StreamCodec&lt;RegistryFriendlyByteBuf, YourResearchEffect&gt; streamCodec() {\n        return STREAM_CODEC;\n    }\n}\n</code></pre> </li> <li> <p>Register the Serializer: In your main mod class, use a <code>DeferredRegister</code> to register your serializer instance.</p> <pre><code>public static final DeferredRegister&lt;ResearchEffectSerializer&lt;?&gt;&gt; RESEARCH_EFFECT_SERIALIZERS = DeferredRegister.create(ResearchdRegistries.RESEARCH_EFFECT_SERIALIZER, YourModClass.MODID);\n\npublic static final RegistryObject&lt;ResearchEffectSerializer&lt;?&gt;&gt; YOUR_EFFECT_SERIALIZER = RESEARCH_EFFECT_SERIALIZERS.register(\"your_effect\", () -&gt; YourResearchEffect.Serializer.INSTANCE);\n</code></pre> </li> </ol>"},{"location":"addons/#researchmethod-interface","title":"<code>ResearchMethod</code> Interface","text":"<p>A <code>ResearchMethod</code> defines how a research is performed. It's the \"how\" of the research process, whether it's consuming items, spending time, or any other custom logic.</p> <p>To create a research method, you need to implement the <code>ResearchMethod</code> interface.</p> <pre><code>public interface ResearchMethod {\n    boolean canResearch(Player player, ResourceKey&lt;Research&gt; research);\n    void onResearchStart(Player player, ResourceKey&lt;Research&gt; research);\n    ResearchMethodProgress getDefaultProgress();\n    ResourceLocation id();\n    ResearchMethodSerializer&lt;?&gt; getSerializer();\n    // ... other methods\n}\n</code></pre>"},{"location":"addons/#key-methods_1","title":"Key Methods","text":"<ul> <li> <p><code>boolean canResearch(Player player, ResourceKey&lt;Research&gt; research)</code>: This method is a check to see if a research can be started. It should not consume any items or resources. It's used by the UI to determine if the \"start research\" button should be enabled.</p> </li> <li> <p><code>void onResearchStart(Player player, ResourceKey&lt;Research&gt; research)</code>: This method is called when the player starts the research. This is where you should consume items, take resources, or perform any other initial action.</p> </li> <li> <p><code>ResearchMethodProgress getDefaultProgress()</code>: This method should return a <code>ResearchMethodProgress</code> object that represents the initial state of your research method. This is crucial for the progress tracking system. For simple one-off methods, you can return <code>ResearchMethodProgress.one(this)</code>. For methods with a specific progress goal, use <code>ResearchMethodProgress.empty(this, maxProgress)</code>.</p> </li> </ul>"},{"location":"addons/#serialization-and-registration_1","title":"Serialization and Registration","text":"<p>Similar to <code>ResearchEffect</code>, your <code>ResearchMethod</code> needs a serializer.</p> <ol> <li> <p>Create the Serializer: Create a class that implements <code>ResearchMethodSerializer&lt;YourResearchMethod&gt;</code>. Here is the example from <code>ConsumeItemResearchMethod</code>:</p> <pre><code>public static final class Serializer implements ResearchMethodSerializer&lt;ConsumeItemResearchMethod&gt; {\n    public static final Serializer INSTANCE = new Serializer();\n    public static final MapCodec&lt;ConsumeItemResearchMethod&gt; CODEC = RecordCodecBuilder.mapCodec(instance -&gt; instance.group(\n            Ingredient.CODEC.fieldOf(\"item\").forGetter(ConsumeItemResearchMethod::toConsume),\n            Codec.INT.fieldOf(\"count\").forGetter(ConsumeItemResearchMethod::count)\n    ).apply(instance, ConsumeItemResearchMethod::new));\n\n    public static final StreamCodec&lt;RegistryFriendlyByteBuf, ConsumeItemResearchMethod&gt; STREAM_CODEC = StreamCodec.composite(\n            Ingredient.CONTENTS_STREAM_CODEC,\n            ConsumeItemResearchMethod::toConsume,\n            ByteBufCodecs.INT,\n            ConsumeItemResearchMethod::count,\n            ConsumeItemResearchMethod::new\n    );\n    // ...\n}\n</code></pre> </li> <li> <p>Register the Serializer: In your main mod class, use a <code>DeferredRegister</code> to register your serializer.</p> <pre><code>public static final DeferredRegister&lt;ResearchMethodSerializer&lt;?&gt;&gt; RESEARCH_METHOD_SERIALIZERS = DeferredRegister.create(ResearchdRegistries.RESEARCH_METHOD_SERIALIZER, YourModClass.MODID);\n\npublic static final RegistryObject&lt;ResearchMethodSerializer&lt;?&gt;&gt; YOUR_METHOD_SERIALIZER = RESEARCH_METHOD_SERIALIZERS.register(\"your_method\", () -&gt; YourResearchMethod.Serializer.INSTANCE);\n</code></pre> </li> </ol>"},{"location":"addons/#creating-a-custom-researchmethod","title":"Creating a Custom <code>ResearchMethod</code>","text":"<p>Let's walk through the <code>ConsumeItemResearchMethod</code> as an example of how to create a custom research method.</p>"},{"location":"addons/#1-the-class-definition","title":"1. The Class Definition","text":"<p><code>ConsumeItemResearchMethod</code> is a record that holds the <code>Ingredient</code> to consume and the <code>count</code>.</p> <pre><code>public record ConsumeItemResearchMethod(Ingredient toConsume, int count) implements ResearchMethod {\n    // ...\n}\n</code></pre>"},{"location":"addons/#2-canresearch","title":"2. <code>canResearch</code>","text":"<p>This method checks if the player has the required items in their inventory. It does not remove the items.</p> <pre><code>@Override\npublic boolean canResearch(Player player, ResourceKey&lt;Research&gt; research) {\n    int amount = 0;\n    for (int i = 0; i &lt; player.getInventory().getContainerSize(); i++) {\n        ItemStack item = player.getInventory().getItem(i);\n        if (this.toConsume.test(item)) {\n            amount += item.getCount();\n            if (amount &gt;= this.count) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n</code></pre>"},{"location":"addons/#3-onresearchstart","title":"3. <code>onResearchStart</code>","text":"<p>This method is called when the research begins. It removes the required items from the player's inventory.</p> <pre><code>@Override\npublic void onResearchStart(Player player, ResourceKey&lt;Research&gt; research) {\n    Inventory inventory = player.getInventory();\n    for (int i = 0; i &lt; inventory.getContainerSize(); i++) {\n        ItemStack item = inventory.getItem(i);\n        if (this.toConsume.test(item)) {\n            int toRemove = Math.min(this.count, item.getMaxStackSize());\n            inventory.removeItem(i, toRemove);\n        }\n    }\n}\n</code></pre>"},{"location":"addons/#4-getdefaultprogress","title":"4. <code>getDefaultProgress</code>","text":"<p>This method sets up the initial progress state. The <code>maxProgress</code> is set to the number of items that need to be consumed.</p> <pre><code>@Override\npublic ResearchMethodProgress getDefaultProgress() {\n    return ResearchMethodProgress.empty(this, this.count);\n}\n</code></pre>"},{"location":"addons/#understanding-and-updating-progress","title":"Understanding and Updating Progress","text":"<p><code>ResearchMethod</code>s do not update their own progress directly. The progress is managed by a central system involving <code>ResearchTeam</code> and <code>TeamResearchProgress</code>.</p> <p><code>TeamResearchProgress</code> holds the progress for all researches for a team. You can get the progress for a specific research method and update it.</p> <p>Here's a conceptual example of how you might update the progress for your custom research method from your own block entity or event handler:</p> <pre><code>// Get the ResearchTeamMap for the current level\nResearchTeamMap teamMap = ResearchdSavedData.TEAM_RESEARCH.get().getData(level);\n\n// Get the team for the player\nResearchTeam team = teamMap.getTeamByPlayer(player);\n\nif (team != null) {\n    // Get the team's research progress\n    TeamResearchProgress teamProgress = team.getResearchProgress();\n\n    // Get all valid, non-completed research methods of your custom type\n    List&lt;ResearchMethodProgress&gt; validMethods = teamProgress.getAllValidMethodProgress(YourCustomResearchMethod.class);\n\n    if (validMethods != null) {\n        for (ResearchMethodProgress progress : validMethods) {\n            // Your logic to update the progress\n            float currentProgress = progress.getProgress();\n            progress.setProgress(currentProgress + 1); // Increment progress\n\n            // The mod will handle checking if the progress is complete and finishing the research.\n        }\n    }\n}\n</code></pre> <p>By using <code>teamProgress.getAllValidMethodProgress(YourCustomResearchMethod.class)</code>, you can get a list of all active research methods of your custom type and update their progress as needed.</p>"},{"location":"gameplay/","title":"Gameplay","text":"<p>This page provides an overview of the core gameplay mechanics of the Researchd mod.</p>"},{"location":"gameplay/#the-research-screen","title":"The Research Screen","text":"<p>The Research Screen is the central hub for all your research activities. It can be opened with a dedicated keybind (check your keybind settings).</p> <p>The screen is composed of several key components:</p>"},{"location":"gameplay/#the-research-graph","title":"The Research Graph","text":"<p>The largest part of the screen is the Research Graph. This is a visual representation of the entire research tree. You can pan to navigate the tree and see how different researches are connected.</p>"},{"location":"gameplay/#the-tech-list","title":"The Tech List","text":"<p>On the left side of the screen, you'll find the Tech List. This is a searchable and filterable list of all available researches. You can use this to quickly find a specific research you're looking for.</p>"},{"location":"gameplay/#the-research-queue","title":"The Research Queue","text":"<p>At the top of the screen is the Research Queue. This widget shows the researches you are currently working on. The research at the front of the queue is the one that is actively being progressed. You can add, remove, and reorder researches in the queue.</p>"},{"location":"gameplay/#the-selected-research-widget","title":"The Selected Research Widget","text":"<p>When you select a research from the graph or the tech list, its details will be displayed in the Selected Research Widget. This widget will show all the Research Methods and Effects of the research.</p>"},{"location":"gameplay/#the-research-lab","title":"The Research Lab","text":"<p>The Research Lab is a multiblock structure that is essential for progressing through certain research paths. Specifically, it is used for researches that require <code>ConsumePackResearchMethod</code>.</p>"},{"location":"gameplay/#the-team-research-screen","title":"The Team Research Screen","text":"<p>It can be opened by pressing 'M' (default).</p> <p>!Currently WIP!</p>"},{"location":"datagen/java/","title":"Java Data Generation","text":"<p>You can register new researches and research packs using the <code>BootstrapContext</code> in your data generation. Researches and research packs are <code>DataPackRegistries</code>, meaning they are loaded from data packs.</p>"},{"location":"datagen/java/#research-packs","title":"Research Packs","text":"<p>Here is an example of how to register a new research pack:</p> <pre><code>import com.portingdeadmods.researchd.ResearchdRegistries;\nimport com.portingdeadmods.researchd.api.research.packs.ResearchPack;\nimport net.minecraft.data.worldgen.BootstrapContext;\nimport net.minecraft.resources.ResourceKey;\n\npublic final class YourModResearchPacks {\n    public static final ResourceKey&lt;SimpleResearchPack&gt; OVERWORLD = key(\"overworld\");\n\n    public static void bootstrap(BootstrapContext&lt;SimpleResearchPack&gt; context) {\n        register(context, OVERWORLD, SimpleResearchPack.builder()\n                .sortingValue(1)\n                .color(222, 0, 0)\n        );\n    }\n\n    private static void register(BootstrapContext&lt;SimpleResearchPack&gt; context, ResourceKey&lt;SimpleResearchPack&gt; key, SimpleResearchPack.Builder builder) {\n        context.register(key, builder.build());\n    }\n\n    private static ResourceKey&lt;SimpleResearchPack&gt; key(String name) {\n        return ResourceKey.create(ResearchdRegistries.RESEARCH_PACK_KEY, YourMod.rl(name));\n    }\n}\n</code></pre>"},{"location":"datagen/java/#researches","title":"Researches","text":"<p>Here is an example of how to register a new research:</p> <pre><code>import com.portingdeadmods.researchd.ResearchdRegistries;\nimport com.portingdeadmods.researchd.api.research.Research;\nimport com.portingdeadmods.researchd.impl.research.SimpleResearch;\nimport com.portingdeadmods.researchd.impl.research.method.ConsumeItemResearchMethod;\nimport net.minecraft.data.worldgen.BootstrapContext;\nimport net.minecraft.resources.ResourceKey;\nimport net.minecraft.world.item.Items;\nimport net.minecraft.world.item.crafting.Ingredient;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.UnaryOperator;\n\npublic final class YourModResearches {\n    private static final Map&lt;ResourceKey&lt;Research&gt;, Research.Builder&lt;?&gt;&gt; RESEARCHES = new HashMap&lt;&gt;();\n\n    public static final ResourceKey&lt;Research&gt; WOOD = register(\"wood\", builder -&gt; builder\n            .icon(Items.OAK_LOG)\n            .researchMethod(\n                    new ConsumeItemResearchMethod(Ingredient.of(Items.DIRT), 8)\n            ));\n\n    public static void bootstrap(BootstrapContext&lt;Research&gt; context) {\n        for (Map.Entry&lt;ResourceKey&lt;Research&gt;, Research.Builder&lt;?&gt;&gt; research : RESEARCHES.entrySet()) {\n            register(context, research.getKey(), research.getValue());\n        }\n    }\n\n    private static void register(BootstrapContext&lt;Research&gt; context, ResourceKey&lt;Research&gt; key, Research.Builder&lt;?&gt; builder) {\n        context.register(key, builder.build());\n    }\n\n    private static ResourceKey&lt;Research&gt; key(String name) {\n        return ResourceKey.create(ResearchdRegistries.RESEARCH_KEY, YourMod.rl(name));\n    }\n\n    private static ResourceKey&lt;Research&gt; register(String name, UnaryOperator&lt;SimpleResearch.Builder&gt; builder) {\n        ResourceKey&lt;Research&gt; key = key(name);\n        RESEARCHES.put(key, builder.apply(SimpleResearch.Builder.of()));\n        return key;\n    }\n}\n</code></pre>"},{"location":"datagen/kubejs/","title":"KubeJS Data Generation","text":"<p>Researchd provides full support for KubeJS for both event scripting and data generation.</p>"},{"location":"datagen/kubejs/#creating-researches-and-packs","title":"Creating Researches and Packs","text":"<p>You can create new researches and research packs using the <code>ServerEvents.registry</code> event in your KubeJS startup scripts. The KubeJS builders are wrappers around the Java builders. For a full list of available methods, see <code>com.portingdeadmods.researchd.compat.kubejs.builders.ResearchBuilder</code>.</p>"},{"location":"datagen/kubejs/#creating-a-research-pack","title":"Creating a Research Pack","text":"<p>Use the <code>researchd:research_pack</code> registry to create new packs.</p> <pre><code>ServerEvents.registry(\"researchd:research_pack\", event =&gt; {\n    event.create(\"kubejs:my_custom_pack\")\n        .sortingValue(100)\n        .color(123, 45, 67);\n});\n</code></pre>"},{"location":"datagen/kubejs/#creating-a-research","title":"Creating a Research","text":"<p>Use the <code>researchd:research</code> registry to create new researches. You can use the <code>prefix to access Java classes like</code>ConsumeItemResearchMethod<code>and</code>Ingredient` directly in your script.</p> <pre><code>ServerEvents.registry(\"researchd:research\", event =&gt; {\n    event.create(\"kubejs:my_custom_research\")\n        .icon(\"minecraft:diamond\")\n        .parents(\"researchd:wood\") // You can reference existing researches here\n        .method(new $ConsumeItemResearchMethod($Ingredient.of(\"minecraft:dirt\"), 16))\n        .effect(new $RecipeUnlockEffect(\"minecraft:diamond_block\"));\n});\n</code></pre>"},{"location":"datagen/kubejs/#event-scripting","title":"Event Scripting","text":"<p>You can listen for the following events in your KubeJS scripts:</p>"},{"location":"datagen/kubejs/#research-completed","title":"Research Completed","text":"<p>This event is fired when a player completes a research.</p> <pre><code>// Example event listener\nResearchdEvents.RESEARCH_COMPLETED.listen(event =&gt; {\n    console.log(`Player ${event.player.username} completed research ${event.research}`);\n});\n</code></pre>"},{"location":"datagen/kubejs/#research-progress","title":"Research Progress","text":"<p>This event is fired when a player makes progress on a research.</p> <pre><code>// Example event listener\nResearchdEvents.RESEARCH_PROGRESS.listen(event =&gt; {\n    console.log(`Player ${event.player.username} has ${event.progress}% progress on research ${event.research}`);\n});\n</code></pre> <p>The event handling is set up in <code>com.portingdeadmods.researchd.compat.KubeJSCompat</code>.</p>"}]}